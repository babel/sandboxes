{"Node objects":{"content":"Node objects","slug":"node-objects","lvl":1,"i":0,"seen":0,"parents":[],"chunk":" Node objects\n\nAST nodes are represented as `Node` objects, which may have any prototype inheritance but which implement the following interface:\n\n```js\ninterface Node {\n  type: string;\n  loc: SourceLocation | null;\n}\n```\n\nThe `type` field is a string representing the AST variant type. Each subtype of `Node` is documented below with the specific string of its `type` field. You can use this field to determine which interface a node implements.\n\nThe `loc` field represents the source location information of the node. If the node contains no information about the source location, the field is `null`; otherwise it is an object consisting of a start position (the position of the first character of the parsed source region) and an end position (the position of the first character after the parsed source region):\n\n```js\ninterface SourceLocation {\n  source: string | null;\n  start: Position;\n  end: Position;\n}\n```\n\nEach `Position` object consists of a `line` number (1-indexed) and a `column` number (0-indexed):\n\n```js\ninterface Position {\n  line: number; // >= 1\n  column: number; // >= 0\n}\n```\n"},"Changes":{"content":"Changes","slug":"changes","lvl":1,"i":1,"seen":0,"parents":[],"chunk":" Changes\n"},"@babel/parser (Babylon) v7":{"content":"@babel/parser (Babylon) v7","slug":"babelparser-babylon-v7","lvl":3,"i":2,"seen":0,"parents":["Changes","Changes"],"chunk":"## @babel/parser (Babylon) v7\n\nFlow: Node renamed from `ExistentialTypeParam` to `ExistsTypeAnnotation` [#322](https://github.com/babel/babylon/pull/322)\n\nFlow: Node renamed from `NumericLiteralTypeAnnotation` to `NumberLiteralTypeAnnotation` [babel/babylon#332](https://github.com/babel/babylon/pull/332)\n\nFlow: Node `Variance` which replaces the string value of the `variance` field on several nodes [babel/babylon#333](https://github.com/babel/babylon/pull/333)\n\nFlow: `ObjectTypeIndexer` location info matches Flow's better [babel/babylon#228](https://github.com/babel/babylon/pull/228)\n\nNode `ForAwaitStatement` has been removed [#349](https://github.com/babel/babylon/pull/349) in favor of modifying `ForOfStatement`\n\n`RestProperty` and `SpreadProperty` have been dropped in favor of `RestElement` and `SpreadElement`.\n"},"Identifier":{"content":"Identifier","slug":"identifier","lvl":1,"i":3,"seen":0,"parents":[],"chunk":" Identifier\n\n```js\ninterface Identifier <: Expression, Pattern {\n  type: \"Identifier\";\n  name: string;\n}\n```\n\nAn identifier. Note that an identifier may be an expression or a destructuring pattern.\n"},"PrivateName":{"content":"PrivateName","slug":"privatename","lvl":1,"i":4,"seen":0,"parents":[],"chunk":" PrivateName\n\n```js\ninterface PrivateName <: Node {\n  type: \"PrivateName\";\n  id: Identifier;\n}\n```\n\nA Private Name Identifier.\n"},"Literals":{"content":"Literals","slug":"literals","lvl":1,"i":5,"seen":0,"parents":[],"chunk":" Literals\n\n```js\ninterface Literal <: Expression { }\n```\n\nA literal token. May or may not represent an expression.\n"},"RegExpLiteral":{"content":"RegExpLiteral","slug":"regexpliteral","lvl":2,"i":6,"seen":0,"parents":["Literals"],"chunk":"# RegExpLiteral\n\n```js\ninterface RegExpLiteral <: Literal {\n  type: \"RegExpLiteral\";\n  pattern: string;\n  flags: string;\n}\n```\n"},"NullLiteral":{"content":"NullLiteral","slug":"nullliteral","lvl":2,"i":7,"seen":0,"parents":["Literals"],"chunk":"# NullLiteral\n\n```js\ninterface NullLiteral <: Literal {\n  type: \"NullLiteral\";\n}\n```\n"},"StringLiteral":{"content":"StringLiteral","slug":"stringliteral","lvl":2,"i":8,"seen":0,"parents":["Literals"],"chunk":"# StringLiteral\n\n```js\ninterface StringLiteral <: Literal {\n  type: \"StringLiteral\";\n  value: string;\n}\n```\n"},"BooleanLiteral":{"content":"BooleanLiteral","slug":"booleanliteral","lvl":2,"i":9,"seen":0,"parents":["Literals"],"chunk":"# BooleanLiteral\n\n```js\ninterface BooleanLiteral <: Literal {\n  type: \"BooleanLiteral\";\n  value: boolean;\n}\n```\n"},"NumericLiteral":{"content":"NumericLiteral","slug":"numericliteral","lvl":2,"i":10,"seen":0,"parents":["Literals"],"chunk":"# NumericLiteral\n\n```js\ninterface NumericLiteral <: Literal {\n  type: \"NumericLiteral\";\n  value: number;\n}\n```\n"},"BigIntLiteral":{"content":"BigIntLiteral","slug":"bigintliteral","lvl":2,"i":11,"seen":0,"parents":["Literals"],"chunk":"# BigIntLiteral\n\n```js\ninterface BigIntLiteral <: Literal {\n  type: \"BigIntLiteral\";\n  value: string;\n}\n```\n\nThe `value` property is the string representation of the `BigInt` value. It doesn't include the suffix `n`.\n"},"Programs":{"content":"Programs","slug":"programs","lvl":1,"i":12,"seen":0,"parents":[],"chunk":" Programs\n\n```js\ninterface Program <: Node {\n  type: \"Program\";\n  interpreter: InterpreterDirective | null;\n  sourceType: \"script\" | \"module\";\n  body: [ Statement | ModuleDeclaration ];\n  directives: [ Directive ];\n}\n```\n\nA complete program source tree.\n\nParsers must specify `sourceType` as `\"module\"` if the source has been parsed as an ES6 module. Otherwise, `sourceType` must be `\"script\"`.\n"},"Functions":{"content":"Functions","slug":"functions","lvl":1,"i":13,"seen":0,"parents":[],"chunk":" Functions\n\n```js\ninterface Function <: Node {\n  id: Identifier | null;\n  params: [ Pattern ];\n  body: BlockStatement;\n  generator: boolean;\n  async: boolean;\n}\n```\n\nA function [declaration](#functiondeclaration) or [expression](#functionexpression).\n"},"Statements":{"content":"Statements","slug":"statements","lvl":1,"i":14,"seen":0,"parents":[],"chunk":" Statements\n\n```js\ninterface Statement <: Node { }\n```\n\nAny statement.\n"},"ExpressionStatement":{"content":"ExpressionStatement","slug":"expressionstatement","lvl":2,"i":15,"seen":0,"parents":["Statements"],"chunk":"# ExpressionStatement\n\n```js\ninterface ExpressionStatement <: Statement {\n  type: \"ExpressionStatement\";\n  expression: Expression;\n}\n```\n\nAn expression statement, i.e., a statement consisting of a single expression.\n"},"BlockStatement":{"content":"BlockStatement","slug":"blockstatement","lvl":2,"i":16,"seen":0,"parents":["Statements"],"chunk":"# BlockStatement\n\n```js\ninterface BlockStatement <: Statement {\n  type: \"BlockStatement\";\n  body: [ Statement ];\n  directives: [ Directive ];\n}\n```\n\nA block statement, i.e., a sequence of statements surrounded by braces.\n"},"EmptyStatement":{"content":"EmptyStatement","slug":"emptystatement","lvl":2,"i":17,"seen":0,"parents":["Statements"],"chunk":"# EmptyStatement\n\n```js\ninterface EmptyStatement <: Statement {\n  type: \"EmptyStatement\";\n}\n```\n\nAn empty statement, i.e., a solitary semicolon.\n"},"DebuggerStatement":{"content":"DebuggerStatement","slug":"debuggerstatement","lvl":2,"i":18,"seen":0,"parents":["Statements"],"chunk":"# DebuggerStatement\n\n```js\ninterface DebuggerStatement <: Statement {\n  type: \"DebuggerStatement\";\n}\n```\n\nA `debugger` statement.\n"},"WithStatement":{"content":"WithStatement","slug":"withstatement","lvl":2,"i":19,"seen":0,"parents":["Statements"],"chunk":"# WithStatement\n\n```js\ninterface WithStatement <: Statement {\n  type: \"WithStatement\";\n  object: Expression;\n  body: Statement;\n}\n```\n\nA `with` statement.\n"},"Control flow":{"content":"Control flow","slug":"control-flow","lvl":2,"i":20,"seen":0,"parents":["Statements"],"chunk":"# Control flow\n"},"ReturnStatement":{"content":"ReturnStatement","slug":"returnstatement","lvl":3,"i":21,"seen":0,"parents":["Statements","Control flow"],"chunk":"## ReturnStatement\n\n```js\ninterface ReturnStatement <: Statement {\n  type: \"ReturnStatement\";\n  argument: Expression | null;\n}\n```\n\nA `return` statement.\n"},"LabeledStatement":{"content":"LabeledStatement","slug":"labeledstatement","lvl":3,"i":22,"seen":0,"parents":["Statements","Control flow"],"chunk":"## LabeledStatement\n\n```js\ninterface LabeledStatement <: Statement {\n  type: \"LabeledStatement\";\n  label: Identifier;\n  body: Statement;\n}\n```\n\nA labeled statement, i.e., a statement prefixed by a `break`/`continue` label.\n"},"BreakStatement":{"content":"BreakStatement","slug":"breakstatement","lvl":3,"i":23,"seen":0,"parents":["Statements","Control flow"],"chunk":"## BreakStatement\n\n```js\ninterface BreakStatement <: Statement {\n  type: \"BreakStatement\";\n  label: Identifier | null;\n}\n```\n\nA `break` statement.\n"},"ContinueStatement":{"content":"ContinueStatement","slug":"continuestatement","lvl":3,"i":24,"seen":0,"parents":["Statements","Control flow"],"chunk":"## ContinueStatement\n\n```js\ninterface ContinueStatement <: Statement {\n  type: \"ContinueStatement\";\n  label: Identifier | null;\n}\n```\n\nA `continue` statement.\n"},"Choice":{"content":"Choice","slug":"choice","lvl":2,"i":25,"seen":0,"parents":["Statements"],"chunk":"# Choice\n"},"IfStatement":{"content":"IfStatement","slug":"ifstatement","lvl":3,"i":26,"seen":0,"parents":["Statements","Choice"],"chunk":"## IfStatement\n\n```js\ninterface IfStatement <: Statement {\n  type: \"IfStatement\";\n  test: Expression;\n  consequent: Statement;\n  alternate: Statement | null;\n}\n```\n\nAn `if` statement.\n"},"SwitchStatement":{"content":"SwitchStatement","slug":"switchstatement","lvl":3,"i":27,"seen":0,"parents":["Statements","Choice"],"chunk":"## SwitchStatement\n\n```js\ninterface SwitchStatement <: Statement {\n  type: \"SwitchStatement\";\n  discriminant: Expression;\n  cases: [ SwitchCase ];\n}\n```\n\nA `switch` statement.\n"},"SwitchCase":{"content":"SwitchCase","slug":"switchcase","lvl":4,"i":28,"seen":0,"parents":["Statements","Choice","SwitchStatement"],"chunk":"### SwitchCase\n\n```js\ninterface SwitchCase <: Node {\n  type: \"SwitchCase\";\n  test: Expression | null;\n  consequent: [ Statement ];\n}\n```\n\nA `case` (if `test` is an `Expression`) or `default` (if `test === null`) clause in the body of a `switch` statement.\n"},"Exceptions":{"content":"Exceptions","slug":"exceptions","lvl":2,"i":29,"seen":0,"parents":["Statements"],"chunk":"# Exceptions\n"},"ThrowStatement":{"content":"ThrowStatement","slug":"throwstatement","lvl":3,"i":30,"seen":0,"parents":["Statements","Exceptions"],"chunk":"## ThrowStatement\n\n```js\ninterface ThrowStatement <: Statement {\n  type: \"ThrowStatement\";\n  argument: Expression;\n}\n```\n\nA `throw` statement.\n"},"TryStatement":{"content":"TryStatement","slug":"trystatement","lvl":3,"i":31,"seen":0,"parents":["Statements","Exceptions"],"chunk":"## TryStatement\n\n```js\ninterface TryStatement <: Statement {\n  type: \"TryStatement\";\n  block: BlockStatement;\n  handler: CatchClause | null;\n  finalizer: BlockStatement | null;\n}\n```\n\nA `try` statement. If `handler` is `null` then `finalizer` must be a `BlockStatement`.\n"},"CatchClause":{"content":"CatchClause","slug":"catchclause","lvl":4,"i":32,"seen":0,"parents":["Statements","Exceptions","TryStatement"],"chunk":"### CatchClause\n\n```js\ninterface CatchClause <: Node {\n  type: \"CatchClause\";\n  param?: Pattern;\n  body: BlockStatement;\n}\n```\n\nA `catch` clause following a `try` block.\n"},"Loops":{"content":"Loops","slug":"loops","lvl":2,"i":33,"seen":0,"parents":["Statements"],"chunk":"# Loops\n"},"WhileStatement":{"content":"WhileStatement","slug":"whilestatement","lvl":3,"i":34,"seen":0,"parents":["Statements","Loops"],"chunk":"## WhileStatement\n\n```js\ninterface WhileStatement <: Statement {\n  type: \"WhileStatement\";\n  test: Expression;\n  body: Statement;\n}\n```\n\nA `while` statement.\n"},"DoWhileStatement":{"content":"DoWhileStatement","slug":"dowhilestatement","lvl":3,"i":35,"seen":0,"parents":["Statements","Loops"],"chunk":"## DoWhileStatement\n\n```js\ninterface DoWhileStatement <: Statement {\n  type: \"DoWhileStatement\";\n  body: Statement;\n  test: Expression;\n}\n```\n\nA `do`/`while` statement.\n"},"ForStatement":{"content":"ForStatement","slug":"forstatement","lvl":3,"i":36,"seen":0,"parents":["Statements","Loops"],"chunk":"## ForStatement\n\n```js\ninterface ForStatement <: Statement {\n  type: \"ForStatement\";\n  init: VariableDeclaration | Expression | null;\n  test: Expression | null;\n  update: Expression | null;\n  body: Statement;\n}\n```\n\nA `for` statement.\n"},"ForInStatement":{"content":"ForInStatement","slug":"forinstatement","lvl":3,"i":37,"seen":0,"parents":["Statements","Loops"],"chunk":"## ForInStatement\n\n```js\ninterface ForInStatement <: Statement {\n  type: \"ForInStatement\";\n  left: VariableDeclaration |  Expression;\n  right: Expression;\n  body: Statement;\n}\n```\n\nA `for`/`in` statement.\n"},"ForOfStatement":{"content":"ForOfStatement","slug":"forofstatement","lvl":2,"i":38,"seen":0,"parents":["Statements"],"chunk":"# ForOfStatement\n\n```js\ninterface ForOfStatement <: ForInStatement {\n  type: \"ForOfStatement\";\n  await: boolean;\n}\n```\n"},"Declarations":{"content":"Declarations","slug":"declarations","lvl":1,"i":39,"seen":0,"parents":[],"chunk":" Declarations\n\n```js\ninterface Declaration <: Statement { }\n```\n\nAny declaration node. Note that declarations are considered statements; this is because declarations can appear in any statement context.\n"},"FunctionDeclaration":{"content":"FunctionDeclaration","slug":"functiondeclaration","lvl":2,"i":40,"seen":0,"parents":["Declarations"],"chunk":"# FunctionDeclaration\n\n```js\ninterface FunctionDeclaration <: Function, Declaration {\n  type: \"FunctionDeclaration\";\n  id: Identifier;\n}\n```\n\nA function declaration. Note that unlike in the parent interface `Function`, the `id` cannot be `null`, except when this is the child of an `ExportDefaultDeclaration`.\n"},"VariableDeclaration":{"content":"VariableDeclaration","slug":"variabledeclaration","lvl":2,"i":41,"seen":0,"parents":["Declarations"],"chunk":"# VariableDeclaration\n\n```js\ninterface VariableDeclaration <: Declaration {\n  type: \"VariableDeclaration\";\n  declarations: [ VariableDeclarator ];\n  kind: \"var\" | \"let\" | \"const\";\n}\n```\n\nA variable declaration.\n"},"VariableDeclarator":{"content":"VariableDeclarator","slug":"variabledeclarator","lvl":3,"i":42,"seen":0,"parents":["Declarations","VariableDeclaration"],"chunk":"## VariableDeclarator\n\n```js\ninterface VariableDeclarator <: Node {\n  type: \"VariableDeclarator\";\n  id: Pattern;\n  init: Expression | null;\n}\n```\n\nA variable declarator.\n"},"Misc":{"content":"Misc","slug":"misc","lvl":1,"i":43,"seen":0,"parents":[],"chunk":" Misc\n"},"Decorator":{"content":"Decorator","slug":"decorator","lvl":2,"i":44,"seen":0,"parents":["Misc"],"chunk":"# Decorator\n\n```js\ninterface Decorator <: Node {\n  type: \"Decorator\";\n  expression: Expression;\n}\n```\n"},"Directive":{"content":"Directive","slug":"directive","lvl":2,"i":45,"seen":0,"parents":["Misc"],"chunk":"# Directive\n\n```js\ninterface Directive <: Node {\n  type: \"Directive\";\n  value: DirectiveLiteral;\n}\n```\n"},"DirectiveLiteral":{"content":"DirectiveLiteral","slug":"directiveliteral","lvl":2,"i":46,"seen":0,"parents":["Misc"],"chunk":"# DirectiveLiteral\n\n```js\ninterface DirectiveLiteral <: StringLiteral {\n  type: \"DirectiveLiteral\";\n}\n```\n"},"InterpreterDirective":{"content":"InterpreterDirective","slug":"interpreterdirective","lvl":2,"i":47,"seen":0,"parents":["Misc"],"chunk":"# InterpreterDirective\n\n```js\ninterface InterpreterDirective <: StringLiteral {\n  type: \"InterpreterDirective\";\n}\n```\n"},"Expressions":{"content":"Expressions","slug":"expressions","lvl":1,"i":48,"seen":0,"parents":[],"chunk":" Expressions\n\n```js\ninterface Expression <: Node { }\n```\n\nAny expression node. Since the left-hand side of an assignment may be any expression in general, an expression can also be a pattern.\n"},"Super":{"content":"Super","slug":"super","lvl":2,"i":49,"seen":0,"parents":["Expressions"],"chunk":"# Super\n\n```js\ninterface Super <: Node {\n    type: \"Super\";\n}\n```\n\nA `super` pseudo-expression.\n"},"Import":{"content":"Import","slug":"import","lvl":2,"i":50,"seen":0,"parents":["Expressions"],"chunk":"# Import\n\n```js\ninterface Import <: Node {\n    type: \"Import\";\n}\n```\n\nA `import` pseudo-expression.\n"},"ThisExpression":{"content":"ThisExpression","slug":"thisexpression","lvl":2,"i":51,"seen":0,"parents":["Expressions"],"chunk":"# ThisExpression\n\n```js\ninterface ThisExpression <: Expression {\n  type: \"ThisExpression\";\n}\n```\n\nA `this` expression.\n"},"ArrowFunctionExpression":{"content":"ArrowFunctionExpression","slug":"arrowfunctionexpression","lvl":2,"i":52,"seen":0,"parents":["Expressions"],"chunk":"# ArrowFunctionExpression\n\n```js\ninterface ArrowFunctionExpression <: Function, Expression {\n  type: \"ArrowFunctionExpression\";\n  body: BlockStatement | Expression;\n}\n```\n\nA fat arrow function expression, e.g., `let foo = (bar) => { /* body */ }`.\n"},"YieldExpression":{"content":"YieldExpression","slug":"yieldexpression","lvl":2,"i":53,"seen":0,"parents":["Expressions"],"chunk":"# YieldExpression\n\n```js\ninterface YieldExpression <: Expression {\n  type: \"YieldExpression\";\n  argument: Expression | null;\n  delegate: boolean;\n}\n```\n\nA `yield` expression.\n"},"AwaitExpression":{"content":"AwaitExpression","slug":"awaitexpression","lvl":2,"i":54,"seen":0,"parents":["Expressions"],"chunk":"# AwaitExpression\n\n```js\ninterface AwaitExpression <: Expression {\n  type: \"AwaitExpression\";\n  argument: Expression | null;\n}\n```\n\nA `await` expression.\n"},"ArrayExpression":{"content":"ArrayExpression","slug":"arrayexpression","lvl":2,"i":55,"seen":0,"parents":["Expressions"],"chunk":"# ArrayExpression\n\n```js\ninterface ArrayExpression <: Expression {\n  type: \"ArrayExpression\";\n  elements: [ Expression | SpreadElement | null ];\n}\n```\n\nAn array expression.\n"},"ObjectExpression":{"content":"ObjectExpression","slug":"objectexpression","lvl":2,"i":56,"seen":0,"parents":["Expressions"],"chunk":"# ObjectExpression\n\n```js\ninterface ObjectExpression <: Expression {\n  type: \"ObjectExpression\";\n  properties: [ ObjectProperty | ObjectMethod | SpreadElement ];\n}\n```\n\nAn object expression.\n"},"ObjectMember":{"content":"ObjectMember","slug":"objectmember","lvl":3,"i":57,"seen":0,"parents":["Expressions","ObjectExpression"],"chunk":"## ObjectMember\n\n```js\ninterface ObjectMember <: Node {\n  key: Expression;\n  computed: boolean;\n  decorators: [ Decorator ];\n}\n```\n"},"ObjectProperty":{"content":"ObjectProperty","slug":"objectproperty","lvl":4,"i":58,"seen":0,"parents":["Expressions","ObjectExpression","ObjectMember"],"chunk":"### ObjectProperty\n\n```js\ninterface ObjectProperty <: ObjectMember {\n  type: \"ObjectProperty\";\n  shorthand: boolean;\n  value: Expression;\n}\n```\n"},"ObjectMethod":{"content":"ObjectMethod","slug":"objectmethod","lvl":4,"i":59,"seen":0,"parents":["Expressions","ObjectExpression","ObjectMember"],"chunk":"### ObjectMethod\n\n```js\ninterface ObjectMethod <: ObjectMember, Function {\n  type: \"ObjectMethod\";\n  kind: \"get\" | \"set\" | \"method\";\n}\n```\n"},"RecordExpression":{"content":"RecordExpression","slug":"recordexpression","lvl":2,"i":60,"seen":0,"parents":["Expressions"],"chunk":"# RecordExpression\n\n```js\ninterface RecordExpression <: Expression {\n  type: \"RecordExpression\";\n  properties: [ ObjectProperty | ObjectMethod | SpreadElement ];\n}\n```\n"},"TupleExpression":{"content":"TupleExpression","slug":"tupleexpression","lvl":2,"i":61,"seen":0,"parents":["Expressions"],"chunk":"# TupleExpression\n\n```js\ninterface TupleExpression <: Expression {\n  type: \"TupleExpression\";\n  elements: [ Expression | SpreadElement | null ];\n}\n```\n"},"FunctionExpression":{"content":"FunctionExpression","slug":"functionexpression","lvl":2,"i":62,"seen":0,"parents":["Expressions"],"chunk":"# FunctionExpression\n\n```js\ninterface FunctionExpression <: Function, Expression {\n  type: \"FunctionExpression\";\n}\n```\n\nA `function` expression.\n"},"Unary operations":{"content":"Unary operations","slug":"unary-operations","lvl":2,"i":63,"seen":0,"parents":["Expressions"],"chunk":"# Unary operations\n"},"UnaryExpression":{"content":"UnaryExpression","slug":"unaryexpression","lvl":3,"i":64,"seen":0,"parents":["Expressions","Unary operations"],"chunk":"## UnaryExpression\n\n```js\ninterface UnaryExpression <: Expression {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: boolean;\n  argument: Expression;\n}\n```\n\nA unary operator expression.\n"},"UnaryOperator":{"content":"UnaryOperator","slug":"unaryoperator","lvl":4,"i":65,"seen":0,"parents":["Expressions","Unary operations","UnaryExpression"],"chunk":"### UnaryOperator\n\n```js\nenum UnaryOperator {\n  \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\" | \"throw\"\n}\n```\n\nA unary operator token.\n"},"UpdateExpression":{"content":"UpdateExpression","slug":"updateexpression","lvl":3,"i":66,"seen":0,"parents":["Expressions","Unary operations"],"chunk":"## UpdateExpression\n\n```js\ninterface UpdateExpression <: Expression {\n  type: \"UpdateExpression\";\n  operator: UpdateOperator;\n  argument: Expression;\n  prefix: boolean;\n}\n```\n\nAn update (increment or decrement) operator expression.\n"},"UpdateOperator":{"content":"UpdateOperator","slug":"updateoperator","lvl":4,"i":67,"seen":0,"parents":["Expressions","Unary operations","UpdateExpression"],"chunk":"### UpdateOperator\n\n```js\nenum UpdateOperator {\n  \"++\" | \"--\"\n}\n```\n\nAn update (increment or decrement) operator token.\n"},"Binary operations":{"content":"Binary operations","slug":"binary-operations","lvl":2,"i":68,"seen":0,"parents":["Expressions"],"chunk":"# Binary operations\n"},"BinaryExpression":{"content":"BinaryExpression","slug":"binaryexpression","lvl":3,"i":69,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## BinaryExpression\n\n```js\ninterface BinaryExpression <: Expression {\n  type: \"BinaryExpression\";\n  operator: BinaryOperator;\n  left: Expression | PrivateName;\n  right: Expression;\n}\n```\n\nA binary operator expression. When `operator` is `in`, the `left` can be a `PrivateName`.\n"},"BinaryOperator":{"content":"BinaryOperator","slug":"binaryoperator","lvl":4,"i":70,"seen":0,"parents":["Expressions","Binary operations","BinaryExpression"],"chunk":"### BinaryOperator\n\n```js\nenum BinaryOperator {\n  \"==\" | \"!=\" | \"===\" | \"!==\"\n     | \"<\" | \"<=\" | \">\" | \">=\"\n     | \"<<\" | \">>\" | \">>>\"\n     | \"+\" | \"-\" | \"*\" | \"/\" | \"%\"\n     | \"**\" | \"|\" | \"^\" | \"&\" | \"in\"\n     | \"instanceof\"\n     | \"|>\"\n}\n```\n\nA binary operator token.\n"},"AssignmentExpression":{"content":"AssignmentExpression","slug":"assignmentexpression","lvl":3,"i":71,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## AssignmentExpression\n\n```js\ninterface AssignmentExpression <: Expression {\n  type: \"AssignmentExpression\";\n  operator: AssignmentOperator;\n  left: Pattern | Expression;\n  right: Expression;\n}\n```\n\nAn assignment operator expression. It has short-circuiting behaviour if the `operator` is one of `\"||=\"`, `\"&&=\"`, and `\"??=\"`.\n"},"AssignmentOperator":{"content":"AssignmentOperator","slug":"assignmentoperator","lvl":4,"i":72,"seen":0,"parents":["Expressions","Binary operations","AssignmentExpression"],"chunk":"### AssignmentOperator\n\n```js\nenum AssignmentOperator {\n  \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" | \"**=\"\n    | \"<<=\" | \">>=\" | \">>>=\"\n    | \"|=\" | \"^=\" | \"&=\"\n    | \"||=\" | \"&&=\" | \"??=\"\n}\n```\n\nAn assignment operator token.\n"},"LogicalExpression":{"content":"LogicalExpression","slug":"logicalexpression","lvl":3,"i":73,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## LogicalExpression\n\n```js\ninterface LogicalExpression <: Expression {\n  type: \"LogicalExpression\";\n  operator: LogicalOperator;\n  left: Expression;\n  right: Expression;\n}\n```\n\nA logical operator expression.\n"},"LogicalOperator":{"content":"LogicalOperator","slug":"logicaloperator","lvl":4,"i":74,"seen":0,"parents":["Expressions","Binary operations","LogicalExpression"],"chunk":"### LogicalOperator\n\n```js\nenum LogicalOperator {\n  \"||\" | \"&&\" | \"??\"\n}\n```\n\nA logical operator token.\n"},"SpreadElement":{"content":"SpreadElement","slug":"spreadelement","lvl":3,"i":75,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## SpreadElement\n\n```js\ninterface SpreadElement <: Node {\n  type: \"SpreadElement\";\n  argument: Expression;\n}\n```\n"},"ArgumentPlaceholder":{"content":"ArgumentPlaceholder","slug":"argumentplaceholder","lvl":3,"i":76,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## ArgumentPlaceholder\n\n```js\ninterface ArgumentPlaceholder <: Node {\n    type: \"ArgumentPlaceholder\";\n}\n```\n"},"MemberExpression":{"content":"MemberExpression","slug":"memberexpression","lvl":3,"i":77,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## MemberExpression\n\n```js\ninterface MemberExpression <: Expression, Pattern {\n  type: \"MemberExpression\";\n  object: Expression | Super;\n  property: Expression | PrivateName;\n  computed: boolean;\n}\n```\n\nA member expression. If `computed` is `true`, the node corresponds to a computed (`a[b]`) member expression and `property` is an `Expression`. If `computed` is `false`, the node corresponds to a static (`a.b`) member expression and `property` is an `Identifier` or a `PrivateName`.\n"},"OptionalMemberExpression":{"content":"OptionalMemberExpression","slug":"optionalmemberexpression","lvl":3,"i":78,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## OptionalMemberExpression\n\n```js\ninterface OptionalMemberExpression <: Expression {\n  type: \"OptionalMemberExpression\";\n  object: Expression;\n  property: Expression | PrivateName;\n  computed: boolean;\n  optional: boolean;\n}\n```\n\nAn optional member expression is a part of the optional chain. When `optional` is `true`, it is the starting element of the optional chain. i.e. In `a?.b.c`, `?.b` is an optional member expression with `optional: true`, `.c` is an optional member expression. See this [gist](https://gist.github.com/JLHwung/567fb29fa2b82bbe164ad9067ff3290f) for more AST examples.\n"},"BindExpression":{"content":"BindExpression","slug":"bindexpression","lvl":3,"i":79,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## BindExpression\n\n```js\ninterface BindExpression <: Expression {\n    type: \"BindExpression\";\n    object: Expression | null;\n    callee: Expression;\n}\n```\n\nIf `object` is `null`, then `callee` should be a `MemberExpression`.\n"},"Pipeline":{"content":"Pipeline","slug":"pipeline","lvl":3,"i":80,"seen":0,"parents":["Expressions","Binary operations"],"chunk":"## Pipeline\n\nThese nodes are used by the Smart Pipeline to determine the type of the expression in a Pipeline Operator Expression. The F# Pipeline uses simple `BinaryExpression`s.\n"},"PipelineBody":{"content":"PipelineBody","slug":"pipelinebody","lvl":4,"i":81,"seen":0,"parents":["Expressions","Binary operations","Pipeline"],"chunk":"### PipelineBody\n\n```js\ninterface PipelineBody <: NodeBase {\n    type: \"PipelineBody\";\n}\n```\n"},"PipelineBareFunctionBody":{"content":"PipelineBareFunctionBody","slug":"pipelinebarefunctionbody","lvl":4,"i":82,"seen":0,"parents":["Expressions","Binary operations","Pipeline"],"chunk":"### PipelineBareFunctionBody\n\n```js\ninterface PipelineBody <: NodeBase {\n    type: \"PipelineBareFunctionBody\";\n    callee: Expression;\n}\n```\n"},"PipelineBareConstructorBody":{"content":"PipelineBareConstructorBody","slug":"pipelinebareconstructorbody","lvl":4,"i":83,"seen":0,"parents":["Expressions","Binary operations","Pipeline"],"chunk":"### PipelineBareConstructorBody\n\n```js\ninterface PipelineBareConstructorBody <: NodeBase {\n    type: \"PipelineBareConstructorBody\";\n    callee: Expression;\n}\n```\n"},"PipelineBareAwaitedFunctionBody":{"content":"PipelineBareAwaitedFunctionBody","slug":"pipelinebareawaitedfunctionbody","lvl":4,"i":84,"seen":0,"parents":["Expressions","Binary operations","Pipeline"],"chunk":"### PipelineBareAwaitedFunctionBody\n\n```js\ninterface PipelineBareConstructorBody <: NodeBase {\n    type: \"PipelineTopicBody\";\n    expression: Expression;\n}\n```\n"},"PipelineTopicBody":{"content":"PipelineTopicBody","slug":"pipelinetopicbody","lvl":4,"i":85,"seen":0,"parents":["Expressions","Binary operations","Pipeline"],"chunk":"### PipelineTopicBody\n\n```js\ninterface PipelineBareConstructorBody <: NodeBase {\n    type: \"PipelineBareAwaitedFunctionBody\";\n    callee: Expression;\n}\n```\n"},"ConditionalExpression":{"content":"ConditionalExpression","slug":"conditionalexpression","lvl":2,"i":86,"seen":0,"parents":["Expressions"],"chunk":"# ConditionalExpression\n\n```js\ninterface ConditionalExpression <: Expression {\n  type: \"ConditionalExpression\";\n  test: Expression;\n  alternate: Expression;\n  consequent: Expression;\n}\n```\n\nA conditional expression, i.e., a ternary `?`/`:` expression.\n"},"CallExpression":{"content":"CallExpression","slug":"callexpression","lvl":2,"i":87,"seen":0,"parents":["Expressions"],"chunk":"# CallExpression\n\n```js\ninterface CallExpression <: Expression {\n  type: \"CallExpression\";\n  callee: Expression | Super | Import;\n  arguments: [ Expression | SpreadElement ];\n}\n```\n\nA function or method call expression. When the `callee` is `Import`, the `arguments` must have only one `Expression` element.\n"},"OptionalCallExpression":{"content":"OptionalCallExpression","slug":"optionalcallexpression","lvl":2,"i":88,"seen":0,"parents":["Expressions"],"chunk":"# OptionalCallExpression\n\n```js\ninterface OptionalCallExpression <: Expression {\n  type: \"OptionalCallExpression\";\n  callee: Expression;\n  arguments: [ Expression | SpreadElement ];\n  optional: boolean;\n}\n```\n\nAn optional call expression is a part of the optional chain. When `optional` is `true`, it is the starting element of the optional chain. i.e. In `f?.()()`, `?.()` is an optional call expression with `optional: true`, `()` is an optional call expression with `optional: false`. See this [gist](https://gist.github.com/JLHwung/567fb29fa2b82bbe164ad9067ff3290f) for more AST examples.\n"},"NewExpression":{"content":"NewExpression","slug":"newexpression","lvl":2,"i":89,"seen":0,"parents":["Expressions"],"chunk":"# NewExpression\n\n```js\ninterface NewExpression <: CallExpression {\n  type: \"NewExpression\";\n}\n```\n\nA `new` expression.\n"},"SequenceExpression":{"content":"SequenceExpression","slug":"sequenceexpression","lvl":2,"i":90,"seen":0,"parents":["Expressions"],"chunk":"# SequenceExpression\n\n```js\ninterface SequenceExpression <: Expression {\n  type: \"SequenceExpression\";\n  expressions: [ Expression ];\n}\n```\n\nA sequence expression, i.e., a comma-separated sequence of expressions.\n"},"ParenthesizedExpression":{"content":"ParenthesizedExpression","slug":"parenthesizedexpression","lvl":2,"i":91,"seen":0,"parents":["Expressions"],"chunk":"# ParenthesizedExpression\n\n```js\ninterface ParenthesizedExpression <: Expression {\n    type \"ParenthesizedExpression\";\n    expression: Expression;\n}\n```\n\nAn expression wrapped by parentheses. By default `@babel/parser` does not create this node, unless the `createParenthesizedExpressions: true` option is passed.\n"},"DoExpression":{"content":"DoExpression","slug":"doexpression","lvl":2,"i":92,"seen":0,"parents":["Expressions"],"chunk":"# DoExpression\n\n```js\ninterface DoExpression <: Expression {\n  type: \"DoExpression\";\n  body: BlockStatement\n}\n```\n"},"Template Literals":{"content":"Template Literals","slug":"template-literals","lvl":1,"i":93,"seen":0,"parents":[],"chunk":" Template Literals\n"},"TemplateLiteral":{"content":"TemplateLiteral","slug":"templateliteral","lvl":2,"i":94,"seen":0,"parents":["Template Literals"],"chunk":"# TemplateLiteral\n\n```js\ninterface TemplateLiteral <: Expression {\n  type: \"TemplateLiteral\";\n  quasis: [ TemplateElement ];\n  expressions: [ Expression ];\n}\n```\n"},"TaggedTemplateExpression":{"content":"TaggedTemplateExpression","slug":"taggedtemplateexpression","lvl":2,"i":95,"seen":0,"parents":["Template Literals"],"chunk":"# TaggedTemplateExpression\n\n```js\ninterface TaggedTemplateExpression <: Expression {\n  type: \"TaggedTemplateExpression\";\n  tag: Expression;\n  quasi: TemplateLiteral;\n}\n```\n"},"TemplateElement":{"content":"TemplateElement","slug":"templateelement","lvl":2,"i":96,"seen":0,"parents":["Template Literals"],"chunk":"# TemplateElement\n\n```js\ninterface TemplateElement <: Node {\n  type: \"TemplateElement\";\n  tail: boolean;\n  value: {\n    cooked: string | null;\n    raw: string;\n  };\n}\n```\n"},"Patterns":{"content":"Patterns","slug":"patterns","lvl":1,"i":97,"seen":0,"parents":[],"chunk":" Patterns\n\n```js\ninterface Pattern <: Node { }\n```\n"},"ObjectPattern":{"content":"ObjectPattern","slug":"objectpattern","lvl":2,"i":98,"seen":0,"parents":["Patterns"],"chunk":"# ObjectPattern\n\n```js\ninterface AssignmentProperty <: ObjectProperty {\n  value: Pattern;\n}\n\ninterface ObjectPattern <: Pattern {\n  type: \"ObjectPattern\";\n  properties: [ AssignmentProperty | RestElement ];\n}\n```\n"},"ArrayPattern":{"content":"ArrayPattern","slug":"arraypattern","lvl":2,"i":99,"seen":0,"parents":["Patterns"],"chunk":"# ArrayPattern\n\n```js\ninterface ArrayPattern <: Pattern {\n  type: \"ArrayPattern\";\n  elements: [ Pattern | null ];\n}\n```\n"},"RestElement":{"content":"RestElement","slug":"restelement","lvl":2,"i":100,"seen":0,"parents":["Patterns"],"chunk":"# RestElement\n\n```js\ninterface RestElement <: Pattern {\n  type: \"RestElement\";\n  argument: Pattern;\n}\n```\n"},"AssignmentPattern":{"content":"AssignmentPattern","slug":"assignmentpattern","lvl":2,"i":101,"seen":0,"parents":["Patterns"],"chunk":"# AssignmentPattern\n\n```js\ninterface AssignmentPattern <: Pattern {\n  type: \"AssignmentPattern\";\n  left: Pattern;\n  right: Expression;\n}\n```\n"},"Classes":{"content":"Classes","slug":"classes","lvl":1,"i":102,"seen":0,"parents":[],"chunk":" Classes\n\n```js\ninterface Class <: Node {\n  id: Identifier | null;\n  superClass: Expression | null;\n  body: ClassBody;\n  decorators: [ Decorator ];\n}\n```\n"},"ClassBody":{"content":"ClassBody","slug":"classbody","lvl":2,"i":103,"seen":0,"parents":["Classes"],"chunk":"# ClassBody\n\n```js\ninterface ClassBody <: Node {\n  type: \"ClassBody\";\n  body: [ ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty ];\n}\n```\n"},"ClassMethod":{"content":"ClassMethod","slug":"classmethod","lvl":2,"i":104,"seen":0,"parents":["Classes"],"chunk":"# ClassMethod\n\n```js\ninterface ClassMethod <: Function {\n  type: \"ClassMethod\";\n  key: Expression;\n  kind: \"constructor\" | \"method\" | \"get\" | \"set\";\n  computed: boolean;\n  static: boolean;\n  decorators: [ Decorator ];\n}\n```\n"},"ClassPrivateMethod":{"content":"ClassPrivateMethod","slug":"classprivatemethod","lvl":2,"i":105,"seen":0,"parents":["Classes"],"chunk":"# ClassPrivateMethod\n\n```js\ninterface ClassPrivateMethod <: Function {\n  type: \"ClassPrivateMethod\";\n  key: PrivateName;\n  kind: \"method\" | \"get\" | \"set\";\n  static: boolean;\n  decorators: [ Decorator ];\n}\n```\n"},"ClassProperty":{"content":"ClassProperty","slug":"classproperty","lvl":2,"i":106,"seen":0,"parents":["Classes"],"chunk":"# ClassProperty\n\n```js\ninterface ClassProperty <: Node {\n  type: \"ClassProperty\";\n  key: Expression;\n  value: Expression;\n  static: boolean;\n  computed: boolean;\n}\n```\n"},"ClassPrivateProperty":{"content":"ClassPrivateProperty","slug":"classprivateproperty","lvl":2,"i":107,"seen":0,"parents":["Classes"],"chunk":"# ClassPrivateProperty\n\n```js\ninterface ClassPrivateProperty <: Node {\n  type: \"ClassPrivateProperty\";\n  key: PrivateName;\n  value: Expression;\n  static: boolean;\n}\n```\n"},"ClassDeclaration":{"content":"ClassDeclaration","slug":"classdeclaration","lvl":2,"i":108,"seen":0,"parents":["Classes"],"chunk":"# ClassDeclaration\n\n```js\ninterface ClassDeclaration <: Class, Declaration {\n  type: \"ClassDeclaration\";\n  id: Identifier;\n}\n```\n"},"ClassExpression":{"content":"ClassExpression","slug":"classexpression","lvl":2,"i":109,"seen":0,"parents":["Classes"],"chunk":"# ClassExpression\n\n```js\ninterface ClassExpression <: Class, Expression {\n  type: \"ClassExpression\";\n}\n```\n"},"MetaProperty":{"content":"MetaProperty","slug":"metaproperty","lvl":2,"i":110,"seen":0,"parents":["Classes"],"chunk":"# MetaProperty\n\n```js\ninterface MetaProperty <: Expression {\n  type: \"MetaProperty\";\n  meta: Identifier;\n  property: Identifier;\n}\n```\n"},"Modules":{"content":"Modules","slug":"modules","lvl":1,"i":111,"seen":0,"parents":[],"chunk":" Modules\n"},"ModuleDeclaration":{"content":"ModuleDeclaration","slug":"moduledeclaration","lvl":2,"i":112,"seen":0,"parents":["Modules"],"chunk":"# ModuleDeclaration\n\n```js\ninterface ModuleDeclaration <: Node { }\n```\n\nA module `import` or `export` declaration.\n"},"ModuleSpecifier":{"content":"ModuleSpecifier","slug":"modulespecifier","lvl":2,"i":113,"seen":0,"parents":["Modules"],"chunk":"# ModuleSpecifier\n\n```js\ninterface ModuleSpecifier <: Node {\n  local: Identifier;\n}\n```\n\nA specifier in an import or export declaration.\n"},"Imports":{"content":"Imports","slug":"imports","lvl":2,"i":114,"seen":0,"parents":["Modules"],"chunk":"# Imports\n"},"ImportDeclaration":{"content":"ImportDeclaration","slug":"importdeclaration","lvl":3,"i":115,"seen":0,"parents":["Modules","Imports"],"chunk":"## ImportDeclaration\n\n```js\ninterface ImportDeclaration <: ModuleDeclaration {\n  type: \"ImportDeclaration\";\n  importKind: null | \"type\" | \"typeof\" | \"value\";\n  specifiers: [ ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier ];\n  source: Literal;\n  attributes?: [ ImportAttribute ];\n}\n```\n\nAn import declaration, e.g., `import foo from \"mod\";`.\n\n> importKind is only set when `flow` plugin enabled in babel-parser\n"},"ImportSpecifier":{"content":"ImportSpecifier","slug":"importspecifier","lvl":3,"i":116,"seen":0,"parents":["Modules","Imports"],"chunk":"## ImportSpecifier\n\n```js\ninterface ImportSpecifier <: ModuleSpecifier {\n  type: \"ImportSpecifier\";\n  imported: Identifier;\n}\n```\n\nAn imported variable binding, e.g., `{foo}` in `import {foo} from \"mod\"` or `{foo as bar}` in `import {foo as bar} from \"mod\"`. The `imported` field refers to the name of the export imported from the module. The `local` field refers to the binding imported into the local module scope. If it is a basic named import, such as in `import {foo} from \"mod\"`, both `imported` and `local` are equivalent `Identifier` nodes; in this case an `Identifier` node representing `foo`. If it is an aliased import, such as in `import {foo as bar} from \"mod\"`, the `imported` field is an `Identifier` node representing `foo`, and the `local` field is an `Identifier` node representing `bar`.\n"},"ImportDefaultSpecifier":{"content":"ImportDefaultSpecifier","slug":"importdefaultspecifier","lvl":3,"i":117,"seen":0,"parents":["Modules","Imports"],"chunk":"## ImportDefaultSpecifier\n\n```js\ninterface ImportDefaultSpecifier <: ModuleSpecifier {\n  type: \"ImportDefaultSpecifier\";\n}\n```\n\nA default import specifier, e.g., `foo` in `import foo from \"mod.js\"`.\n"},"ImportNamespaceSpecifier":{"content":"ImportNamespaceSpecifier","slug":"importnamespacespecifier","lvl":3,"i":118,"seen":0,"parents":["Modules","Imports"],"chunk":"## ImportNamespaceSpecifier\n\n```js\ninterface ImportNamespaceSpecifier <: ModuleSpecifier {\n  type: \"ImportNamespaceSpecifier\";\n}\n```\n\nA namespace import specifier, e.g., `* as foo` in `import * as foo from \"mod.js\"`.\n"},"ImportAttribute":{"content":"ImportAttribute","slug":"importattribute","lvl":3,"i":119,"seen":0,"parents":["Modules","Imports"],"chunk":"## ImportAttribute\n\n```js\ninterface ImportAttribute <: Node {\n  type: \"ImportAttribute\";\n  key: Identifier;\n  value: StringLiteral;\n}\n```\n\nAn attribute specified on the ImportDeclaration.\n"},"Exports":{"content":"Exports","slug":"exports","lvl":2,"i":120,"seen":0,"parents":["Modules"],"chunk":"# Exports\n"},"ExportNamedDeclaration":{"content":"ExportNamedDeclaration","slug":"exportnameddeclaration","lvl":3,"i":121,"seen":0,"parents":["Modules","Exports"],"chunk":"## ExportNamedDeclaration\n\n```js\ninterface ExportNamedDeclaration <: ModuleDeclaration {\n  type: \"ExportNamedDeclaration\";\n  declaration: Declaration | null;\n  specifiers: [ ExportSpecifier ];\n  source: Literal | null;\n}\n```\n\nAn export named declaration, e.g., `export {foo, bar};`, `export {foo} from \"mod\";`, `export var foo = 1;` or `export * as foo from \"bar\";`.\n\n_Note: Having `declaration` populated with non-empty `specifiers` or non-null `source` results in an invalid state._\n"},"ExportSpecifier":{"content":"ExportSpecifier","slug":"exportspecifier","lvl":3,"i":122,"seen":0,"parents":["Modules","Exports"],"chunk":"## ExportSpecifier\n\n```js\ninterface ExportSpecifier <: ModuleSpecifier {\n  type: \"ExportSpecifier\";\n  exported: Identifier;\n  local?: Identifier;\n}\n```\n\nAn exported variable binding, e.g., `{foo}` in `export {foo}` or `{bar as foo}` in `export {bar as foo}`. The `exported` field refers to the name exported in the module. The `local` field refers to the binding into the local module scope. If it is a basic named export, such as in `export {foo}`, both `exported` and `local` are equivalent `Identifier` nodes; in this case an `Identifier` node representing `foo`. If it is an aliased export, such as in `export {bar as foo}`, the `exported` field is an `Identifier` node representing `foo`, and the `local` field is an `Identifier` node representing `bar`.\n"},"ExportDefaultDeclaration":{"content":"ExportDefaultDeclaration","slug":"exportdefaultdeclaration","lvl":3,"i":123,"seen":0,"parents":["Modules","Exports"],"chunk":"## ExportDefaultDeclaration\n\n```js\ninterface OptFunctionDeclaration <: FunctionDeclaration {\n  id: Identifier | null;\n}\n\ninterface OptClassDeclaration <: ClassDeclaration {\n  id: Identifier | null;\n}\n\ninterface ExportDefaultDeclaration <: ModuleDeclaration {\n  type: \"ExportDefaultDeclaration\";\n  declaration: OptFunctionDeclaration | OptClassDeclaration | Expression;\n}\n```\n\nAn export default declaration, e.g., `export default function () {};` or `export default 1;`.\n"},"ExportAllDeclaration":{"content":"ExportAllDeclaration","slug":"exportalldeclaration","lvl":3,"i":124,"seen":0,"parents":["Modules","Exports"],"chunk":"## ExportAllDeclaration\n\n```js\ninterface ExportAllDeclaration <: ModuleDeclaration {\n  type: \"ExportAllDeclaration\";\n  source: Literal;\n}\n```\n\nAn export batch declaration, e.g., `export * from \"mod\";`.\n"}}